##### WARNING #####
#
# Do not edit this file unless you know what you are doing.
#
#
###################

from PyQt5.QtCore import *
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QMessageBox, QApplication
from .settingsgui import Ui_settingsWindow
from .datadictionaryui import DataDictionaryWindow, createDictionaryModel, addDictionary
from .aboutgui import Ui_Dialog
import numpy as np
from datetime import datetime, timedelta
import time
import sys, os
import pampro
from pampro import data_loading, diagnostics, Time_Series, Channel, channel_inference, Bout, Bout_Collection, batch_processing, triaxial_calibration, time_utilities, pampro_utilities, pampro_fourier
from collections import OrderedDict
import collections, re, copy
import pandas as pd
import os.path

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(650, 600)
        MainWindow.setMinimumSize(QtCore.QSize(650, 600))
        MainWindow.setMaximumSize(QtCore.QSize(650, 600))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_8.setObjectName("gridLayout_8")
        self.groupBox_3 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_3.setObjectName("groupBox_3")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.groupBox_3)
        self.gridLayout_7.setObjectName("gridLayout_7")
        self.tabWidget = QtWidgets.QTabWidget(self.groupBox_3)
        self.tabWidget.setObjectName("tabWidget")
        self.datalistTab = QtWidgets.QWidget()
        self.datalistTab.setObjectName("datalistTab")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.datalistTab)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.model = QtGui.QStandardItemModel()
        self.listView = QtWidgets.QListView(self.datalistTab)
        self.listView.setObjectName("listView")
        self.gridLayout_5.addWidget(self.listView, 0, 0, 1, 1)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.filelistSelectAll = QtWidgets.QPushButton(self.datalistTab)
        self.filelistSelectAll.setObjectName("filelistSelectAll")
        self.horizontalLayout_2.addWidget(self.filelistSelectAll)
        self.filelistClearSelection = QtWidgets.QPushButton(self.datalistTab)
        self.filelistClearSelection.setObjectName("filelistClearSelection")
        self.horizontalLayout_2.addWidget(self.filelistClearSelection)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem)
        self.filelistSubmit = QtWidgets.QPushButton(self.datalistTab)
        self.filelistSubmit.setObjectName("filelistSubmit")
        self.horizontalLayout_2.addWidget(self.filelistSubmit)
        self.gridLayout_5.addLayout(self.horizontalLayout_2, 2, 0, 1, 1)
        self.outputfolderLabel = QtWidgets.QLabel(self.datalistTab)
        self.outputfolderLabel.setObjectName("outputfolderLabel")
        self.gridLayout_5.addWidget(self.outputfolderLabel, 1, 0, 1, 1)
        self.listView = QtWidgets.QListView(self.datalistTab)
        self.listView.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        self.listView.setSelectionMode(QtWidgets.QAbstractItemView.MultiSelection)
        self.listView.setProperty("isWrapping", False)
        self.listView.setObjectName("listView")
        self.gridLayout_5.addWidget(self.listView, 0, 0, 1, 1)
        self.tabWidget.addTab(self.datalistTab, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.tab)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.gridLayout_9 = QtWidgets.QGridLayout()
        self.gridLayout_9.setObjectName("gridLayout_9")
        self.statuslabel = QtWidgets.QLabel(self.tab)
        self.statuslabel.setObjectName("statuslabel")
        self.gridLayout_9.addWidget(self.statuslabel, 0, 0, 1, 1)
        self.processStop = QtWidgets.QPushButton(self.tab)
        self.processStop.setMinimumSize(QtCore.QSize(75, 27))
        self.processStop.setMaximumSize(QtCore.QSize(75, 27))
        self.processStop.setObjectName("processStop")
        self.gridLayout_9.addWidget(self.processStop, 0, 1, 1, 1)
        self.gridLayout_6.addLayout(self.gridLayout_9, 3, 0, 2, 1)


        #status tab starts here

        self.tableView = QtWidgets.QTableWidget(self.tab)
        self.tableView.setObjectName("tableView")
        self.tableView_model = self.tableView.model()
        self.tableView.setTextElideMode(QtCore.Qt.ElideLeft)
        self.tableView.setWordWrap(False)
        self.tableView.setColumnCount(3)
        self.tableView.setHorizontalHeaderLabels(['File','Progress','Output'])
        header = self.tableView.horizontalHeader()
#        header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
#        header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
#        header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.tableView.verticalHeader().setVisible(False)
        self.tableView.rowCount()
        self.tableView.setEditTriggers(QtWidgets.QTableWidget.NoEditTriggers)
        self.gridLayout_6.addWidget(self.tableView, 0, 0, 1, 1)
        self.tabWidget.addTab(self.tab, "")
        self.gridLayout_7.addWidget(self.tabWidget, 0, 0, 1, 1)
        self.resultsListAndMapHBL = QtWidgets.QHBoxLayout()
        self.resultsListAndMapHBL.setObjectName("resultsListAndMapHBL")
        self.gridLayout_7.addLayout(self.resultsListAndMapHBL, 1, 0, 1, 1)
        self.gridLayout_8.addWidget(self.groupBox_3, 4, 0, 1, 1)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem1, 1, 0, 1, 1)
        self.groupBox = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox.setObjectName("groupBox")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.groupBox)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.outputfolderEntry = QtWidgets.QLineEdit(self.groupBox)
        self.outputfolderEntry.setObjectName("outputfolderEntry")
        self.gridLayout_4.addWidget(self.outputfolderEntry, 1, 1, 1, 1)
        self.datafilesEntry = QtWidgets.QLineEdit(self.groupBox)
        self.datafilesEntry.setObjectName("datafilesEntry")
        self.gridLayout_4.addWidget(self.datafilesEntry, 0, 1, 1, 1)
        self.browseFilesPush = QtWidgets.QPushButton(self.groupBox)
        self.browseFilesPush.setObjectName("browseFilesPush")
        self.gridLayout_4.addWidget(self.browseFilesPush, 0, 3, 1, 1)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem2, 0, 5, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem3, 1, 5, 1, 1)
        self.browseOutputFolderPush = QtWidgets.QPushButton(self.groupBox)
        self.browseOutputFolderPush.setObjectName("browseOutputFolderPush")
        self.gridLayout_4.addWidget(self.browseOutputFolderPush, 1, 3, 1, 1)
        self.datafilesLabel = QtWidgets.QLabel(self.groupBox)
        self.datafilesLabel.setObjectName("datafilesLabel")
        self.gridLayout_4.addWidget(self.datafilesLabel, 0, 0, 1, 1)
        self.outputfolderlabel = QtWidgets.QLabel(self.groupBox)
        self.outputfolderlabel.setObjectName("outputfolderlabel")
        self.gridLayout_4.addWidget(self.outputfolderlabel, 1, 0, 1, 1)
        self.outputfoldersubmit = QtWidgets.QPushButton(self.groupBox)
        self.outputfoldersubmit.setObjectName("outputfoldersubmit")
        self.gridLayout_4.addWidget(self.outputfoldersubmit, 1, 2, 1, 1)
        self.datafilesubmit = QtWidgets.QPushButton(self.groupBox)
        self.datafilesubmit.setObjectName("datafilesubmit")
        self.gridLayout_4.addWidget(self.datafilesubmit, 0, 2, 1, 1)
        self.gridLayout_8.addWidget(self.groupBox, 0, 0, 1, 1)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem4, 3, 0, 1, 1)
        self.groupBox_2 = QtWidgets.QGroupBox(self.centralwidget)
        self.groupBox_2.setMaximumSize(QtCore.QSize(16777215, 150))
        self.groupBox_2.setObjectName("groupBox_2")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.groupBox_2)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.groupBox_4 = QtWidgets.QGroupBox(self.groupBox_2)
        self.groupBox_4.setMinimumSize(QtCore.QSize(160, 100))
        self.groupBox_4.setMaximumSize(QtCore.QSize(160, 100))
        self.groupBox_4.setObjectName("groupBox_4")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.groupBox_4)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.axivityRadioButton = QtWidgets.QRadioButton(self.groupBox_4)
        self.axivityRadioButton.setObjectName("axivityRadioButton")
        self.buttonGroup = QtWidgets.QButtonGroup(MainWindow)
        self.buttonGroup.setObjectName("buttonGroup")
        self.buttonGroup.addButton(self.axivityRadioButton)
        self.gridLayout_2.addWidget(self.axivityRadioButton, 0, 1, 1, 1)
        self.geneactivRadioButton = QtWidgets.QRadioButton(self.groupBox_4)
        self.geneactivRadioButton.setObjectName("geneactivRadioButton")
        self.buttonGroup.addButton(self.geneactivRadioButton)
        self.gridLayout_2.addWidget(self.geneactivRadioButton, 1, 1, 1, 1)
        self.horizontalLayout_3.addWidget(self.groupBox_4)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.groupBox_6 = QtWidgets.QGroupBox(self.groupBox_2)
        self.groupBox_6.setMinimumSize(QtCore.QSize(160, 100))
        self.groupBox_6.setMaximumSize(QtCore.QSize(160, 100))
        self.groupBox_6.setObjectName("groupBox_6")
        self.gridLayout = QtWidgets.QGridLayout(self.groupBox_6)
        self.gridLayout.setObjectName("gridLayout")
        self.outputresolutionList = QtWidgets.QListWidget(self.groupBox_6)
        self.outputresolutionList.setObjectName("outputresolutionList")
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.outputresolutionList.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.outputresolutionList.addItem(item)
        item = QtWidgets.QListWidgetItem()

        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.outputresolutionList.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.outputresolutionList.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsEditable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled)
        self.outputresolutionList.addItem(item)
        self.gridLayout.addWidget(self.outputresolutionList, 0, 0, 1, 1)
        self.horizontalLayout.addWidget(self.groupBox_6)
        self.horizontalLayout_3.addLayout(self.horizontalLayout)
        self.groupBox_5 = QtWidgets.QGroupBox(self.groupBox_2)
        self.groupBox_5.setMinimumSize(QtCore.QSize(240, 100))
        self.groupBox_5.setMaximumSize(QtCore.QSize(240, 100))
        self.groupBox_5.setObjectName("groupBox_5")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.groupBox_5)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.listWidget = QtWidgets.QListWidget(self.groupBox_5)
        self.listWidget.setMinimumSize(QtCore.QSize(200, 72))
        self.listWidget.setMaximumSize(QtCore.QSize(200, 72))
        self.listWidget.setObjectName("listWidget")
        item = QtWidgets.QListWidgetItem()
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setFlags(QtCore.Qt.ItemIsSelectable|QtCore.Qt.ItemIsDragEnabled|QtCore.Qt.ItemIsUserCheckable|QtCore.Qt.ItemIsEnabled|QtCore.Qt.ItemIsTristate)
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        item = QtWidgets.QListWidgetItem()
        item.setCheckState(QtCore.Qt.Checked)
        self.listWidget.addItem(item)
        self.gridLayout_3.addWidget(self.listWidget, 0, 0, 1, 1)
        self.horizontalLayout_3.addWidget(self.groupBox_5)
        self.gridLayout_8.addWidget(self.groupBox_2, 2, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 652, 21))
        self.menubar.setObjectName("menubar")
        self.menubar.setNativeMenuBar(False)
        self.menuAbout = QtWidgets.QMenu(self.menubar)
        self.menuAbout.setObjectName("menuAbout")
        self.menuView = QtWidgets.QMenu(self.menubar)
        self.menuView.setObjectName("menuView")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionData_Dictionary = QtWidgets.QAction(MainWindow)
        self.actionData_Dictionary.setObjectName("actionData_Dictionary")
        self.actionAbout = QtWidgets.QAction(MainWindow)
        self.actionAbout.setObjectName("actionAbout")
        self.actionDocumentation = QtWidgets.QAction(MainWindow)
        self.actionDocumentation.setObjectName("actionDocumentation")
        self.actionSettings = QtWidgets.QAction(MainWindow)
        self.actionSettings.setObjectName("actionSettings")
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.menuAbout.addAction(self.actionAbout)
        self.menuAbout.addAction(self.actionDocumentation)
        self.menuView.addAction(self.actionData_Dictionary)
        self.menuView.addAction(self.actionSettings)
        self.menuView.addSeparator()
        self.menuView.addAction(self.actionExit)
        self.menubar.addAction(self.menuView.menuAction())
        self.menubar.addAction(self.menuAbout.menuAction())

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        self.actionExit.triggered.connect(MainWindow.close)
        self.browseFilesPush.clicked.connect(MainWindow.browseSlot)
        self.browseOutputFolderPush.clicked.connect(MainWindow.browseFolder)

        self.outputfoldersubmit.clicked.connect(MainWindow.manualfoldersubmit)
        self.datafilesubmit.clicked.connect(MainWindow.manualfilesubmit)
        self.processStop.clicked.connect(self.stop_process)

        self.filelistSelectAll.clicked.connect(self.select)
        self.filelistClearSelection.clicked.connect(self.unselect)
        self.filelistSubmit.clicked.connect(self.onAccepted)

        self.actionData_Dictionary.triggered.connect(self.open_datadictionaryUI)
        self.actionSettings.triggered.connect(self.open_Ui_settingsWindow)
        self.actionAbout.triggered.connect(self.open_Ui_aboutWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        self.show()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Wave"))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("Logo.svg"), QtGui.QIcon.Selected, QtGui.QIcon.On)
        MainWindow.setWindowIcon(icon)
        self.groupBox_3.setTitle(_translate("MainWindow", "Processing"))
        self.filelistSelectAll.setText(_translate("MainWindow", "Select all"))
        self.filelistClearSelection.setText(_translate("MainWindow", "Clear selection"))
        self.filelistSubmit.setText(_translate("MainWindow", "Submit"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.datalistTab), _translate("MainWindow", "Data"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Status"))
        self.groupBox.setTitle(_translate("MainWindow", "Files"))
        self.browseFilesPush.setText(_translate("MainWindow", "Browse"))
        self.browseOutputFolderPush.setText(_translate("MainWindow", "Browse"))
        self.datafilesLabel.setText(_translate("MainWindow", "Data Files:"))
        self.outputfolderlabel.setText(_translate("MainWindow", "Output Folder:"))
        self.outputfoldersubmit.setText(_translate("MainWindow", "Submit"))
        self.datafilesubmit.setText(_translate("MainWindow", "Submit"))
        self.processStop.setText(_translate("MainWindow", "Stop"))
        self.groupBox_2.setTitle(_translate("MainWindow", "Output Settings"))
        self.groupBox_4.setTitle(_translate("MainWindow", "Monitor Type"))
        self.axivityRadioButton.setText(_translate("MainWindow", "Axivity"))
        self.axivityRadioButton.setChecked(True)
        self.geneactivRadioButton.setText(_translate("MainWindow", "GeneActiv"))
        self.groupBox_6.setTitle(_translate("MainWindow", "Output Resolution (mins)"))
        __sortingEnabled = self.outputresolutionList.isSortingEnabled()
        self.outputresolutionList.setSortingEnabled(False)
        item = self.outputresolutionList.item(0)
        item.setText(_translate("MainWindow", "1"))
        item = self.outputresolutionList.item(1)
        item.setText(_translate("MainWindow", "60"))
        self.outputresolutionList.setSortingEnabled(__sortingEnabled)
        self.groupBox_5.setTitle(_translate("MainWindow", "Output Variables"))
        __sortingEnabled = self.listWidget.isSortingEnabled()
        self.listWidget.setSortingEnabled(False)
        item = self.listWidget.item(0)
        item.setText(_translate("MainWindow", "ENMO"))
        item = self.listWidget.item(1)
        item.setText(_translate("MainWindow", "Pitch"))
        item = self.listWidget.item(2)
        item.setText(_translate("MainWindow", "Roll"))
        item = self.listWidget.item(3)
        item.setText(_translate("MainWindow", "Temperature"))
        item = self.listWidget.item(4)
        item.setText(_translate("MainWindow", "Integrity"))
        item = self.listWidget.item(5)
        item.setText(_translate("MainWindow", "HPFVM"))
        item = self.listWidget.item(6)
        item.setText(_translate("MainWindow", "Battery"))
        self.listWidget.setSortingEnabled(__sortingEnabled)
        self.menuAbout.setTitle(_translate("MainWindow", "Help"))
        self.menuView.setTitle(_translate("MainWindow", "View"))
        self.actionData_Dictionary.setText(_translate("MainWindow", "Data Dictionary"))
        self.actionAbout.setText(_translate("MainWindow", "About"))
        self.actionDocumentation.setText(_translate("MainWindow", "Documentation"))
        self.actionSettings.setText(_translate("MainWindow", "Settings"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))

        self.outputfolderLabel.setText(_translate("MainWindow", "Output Folder:"))
        self.statuslabel.setText(_translate("MainWindow", "Processing: Idle"))
        #self.statusbar.showMessage('Advanced Settings Template: Default')
        # Tool tips

        self.groupBox_6.setToolTip(_translate("MainWindow", "The output level is given in minutes, where multiple levels can be selected. Click to add or remove levels."))
        self.groupBox_5.setToolTip(_translate("MainWindow", "Select the desired outputs for processed files"))
        self.processStop.setToolTip(_translate("MainWindow", "This will stop all files with status either \'Pending\' or \'Running\'"))
        self.browseFilesPush.setToolTip(_translate("MainWindow", "Browse location for data files"))
        self.browseOutputFolderPush.setToolTip(_translate("MainWindow", "Browse location for output folder"))
        self.filelistSubmit.setToolTip(_translate("MainWindow", "Start processing selected files"))


    def browseSlot( self ):
        #Return to file path list self.files and filetype filetype
        self.files, filetype = QFileDialog.getOpenFileNames(self,
                                                            "Multiple file selection",
                                                            "./",
                                                            "All Files (*);;Axivity (*.bin);; GeneActiv (*.cwa)")

        checked = False
        for string in self.files:
            item = QtGui.QStandardItem(string)
            item.setCheckable(True)
            check = \
                (QtCore.Qt.Checked if checked else QtCore.Qt.Unchecked)
            
            item.setCheckState(check)
            self.model.appendRow(item)

        self.listView.setModel(self.model)

    def browseFolder(self):
        folder_temp = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select output folder:', 'C:\\',
                                                          QtWidgets.QFileDialog.ShowDirsOnly)
        self.outputfolderEntry.setText(folder_temp)

    def manualfoldersubmit(self):
        textboxValue = self.outputfolderEntry.text()
        if os.path.isdir(textboxValue) is True:
            self.folder = self.outputfolderEntry.text()
            QMessageBox.information(self, 'Wave', "Output Folder: " + textboxValue, QMessageBox.Ok, QMessageBox.Ok)

            folder_name = "Output Folder: {}".format(self.folder)
            self.outputfolderLabel.setText(folder_name)

            self.outputfolderEntry.setText('')

        elif os.path.isdir(textboxValue) is False:
            self.datafilesEntry.setText("")
            error = 'Invalid folder'
            detailed_error = 'The folder name you have entered is not recognised. Please check to ensure you have entered the folder name correctly, including the full path.'
            self.error_message_warning(error, detailed_error)

    def manualfilesubmit(self):
        textboxValue = self.datafilesEntry.text()
        if os.path.isfile(textboxValue) is True:
            QMessageBox.question(self, 'Wave: File Entry', "Files: " + textboxValue, QMessageBox.Ok, QMessageBox.Ok)
            self.datafilesEntry.setText("")
            checked = False
            item = QtGui.QStandardItem(textboxValue)
            item.setCheckable(True)
            check = \
                (QtCore.Qt.Checked if checked else QtCore.Qt.Unchecked)

            item.setCheckState(check)
            self.model.appendRow(item)

            self.listView.setModel(self.model)
        elif os.path.isfile(textboxValue) is False:
            self.datafilesEntry.setText("")
            error = 'Invalid file'
            detailed_error = 'The filename you have entered is not recognised. Please check to ensure you have entered the filename correctly, including the full path to file.'
            self.error_message_warning(error, detailed_error)

    def open_datadictionaryUI(self):
        #self.window = QtWidgets.QMainWindow()
        self.datadictionary = DataDictionaryWindow()
        self.datadictionary.setSourceModel(createDictionaryModel(self.datadictionary))
        #self.datadictionary.setupUi(self.window)
        self.datadictionary.show()

    def open_Ui_settingsWindow(self):
        self.window = QtWidgets.QMainWindow()
        self.ui = Ui_settingsWindow()
        self.ui.setupUi(self.window)
        self.window.show()

    def open_Ui_aboutWindow(self):
        dialog = QtWidgets.QDialog()
        dialog.ui = Ui_Dialog()
        dialog.ui.setupUi(dialog)
        dialog.exec_()
        dialog.show()

    def open_Ui_documentation(self):
        dialog = QtWidgets.QDialog()
        dialog.ui = Documentation_Dialog()
        dialog.ui.setupUi(dialog)
        dialog.exec_()
        dialog.show()

    def select(self):
        for i in range(self.model.rowCount()):
            item = self.model.item(i)
            item.setCheckState(QtCore.Qt.Checked)

    def unselect(self):
        for i in range(self.model.rowCount()):
            item = self.model.item(i)
            item.setCheckState(QtCore.Qt.Unchecked)

    def onAccepted(self):

        self.choices = [self.model.item(i).text() for i in
                            range(self.model.rowCount())
                            if self.model.item(i).checkState()
                            == QtCore.Qt.Checked]
        self.accept()

    def accept(self):

        file_list = self.choices

        Ui_MainWindow.results_folder = str(self.folder)
        Ui_MainWindow.indexedRow = self.tableView.rowCount()

        for i in file_list:
            process_status = 'Pending'
            row = self.tableView.rowCount()
            self.tableView.insertRow(row)
            self.tableView.setItem(row,0,QtWidgets.QTableWidgetItem(i))
            item = self.tableView.item(row, 0)
            item.setTextAlignment(QtCore.Qt.AlignLeft)
            item.setTextAlignment(QtCore.Qt.AlignVCenter)
            self.tableView.setItem(row,1,QtWidgets.QTableWidgetItem(process_status))
            self.tableView.setItem(row,2,QtWidgets.QTableWidgetItem(Ui_MainWindow.results_folder))
            item = self.tableView.item(row, 2)
            item.setTextAlignment(QtCore.Qt.AlignVCenter)

        Ui_MainWindow.monitor_type = self.buttonGroup.checkedButton().text()
        Ui_MainWindow.pass_table = self.tableView
        Ui_MainWindow.pass_table_count = self.tableView_model.rowCount()
        Ui_MainWindow.outputresolutionList = self.outputresolutionList
        Ui_MainWindow.listWidget = self.listWidget

        self.process_file()

    @pyqtSlot(int)
    def onFinished(self, i):
        self.thread.quit()

    def process_file(self):

        if hasattr(self.thread, 'isRunning') is False:
            QMessageBox.information(self, 'Wave', 'File(s) Successfully Submitted', QMessageBox.Ok, QMessageBox.Ok)
            self.thread = QThread()
            self.worker = WorkerThread()
            self.worker.moveToThread(self.thread)
            self.thread.started.connect(self.worker.run)
            self.thread.start()
            self.worker.update_row.connect(self.evt_update_row)
            self.worker.update_progress.connect(self.evt_update_progress)
            self.worker.update_progress_number.connect(self.evt_update_status_label)
            self.worker.update_error.connect(self.evt_update_error)
            self.worker.finished_check.connect(self.evt_worker_finished)

        elif hasattr(self.thread, 'isRunning') is True:
            if self.thread.isRunning() is True:
                error = 'File submission failed.'
                error_detailed = 'The application is currently processing a prior submission. If you wish to submit further jobs, either wait until the current process has completed or terminate the process.'
                self.error_message_information(error,error_detailed)
            elif self.thread.isRunning() is False:
                QMessageBox.information(self, 'Wave', 'File(s) Successfully Submitted', QMessageBox.Ok, QMessageBox.Ok)
                self.thread = QThread()
                self.worker = WorkerThread()
                self.worker.moveToThread(self.thread)
                self.thread.started.connect(self.worker.run)
                self.thread.start()
                self.worker.update_row.connect(self.evt_update_row)
                self.worker.update_progress.connect(self.evt_update_progress)
                self.worker.update_progress_number.connect(self.evt_update_status_label)
                self.worker.update_error.connect(self.evt_update_error)
                self.worker.finished_check.connect(self.evt_worker_finished)

    @pyqtSlot(str)
    def evt_update_progress(self, val):
        self.process_progress = val
        self.tableView.setItem(self.process_row, 1, QtWidgets.QTableWidgetItem(self.process_progress))

    @pyqtSlot(int)
    def evt_update_status_label(self, count):
        processing_status = "Processing: {} of {}".format(count, len(self.choices))
        self.statuslabel.setText(processing_status)

    @pyqtSlot(int)
    def evt_update_row(self, row):
        self.process_row = row
        #print(self.process_row)

    def evt_update_error(self, error_code):
        print(error_code)

    @pyqtSlot(bool)
    def evt_worker_finished(self, status):
        if status is True:
            processing_status = "Processing: Idle"
            self.statuslabel.setText(processing_status)
            self.thread.exit()
            self.thread.quit()

    def stop_process(self):
        try:
            hasattr(self.thread, 'isRunning')
            if self.thread.isRunning() is True:
                dlg = QMessageBox(self)
                dlg.setWindowTitle('Process Interrupt')
                dlg.setText("Are you sure you want to cancel processing the running jobs?")
                dlg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                dlg.setIcon(QMessageBox.Question)
                dlg.setWindowIcon(QtGui.QIcon('Logo.svg'))
                button = dlg.exec()
                if button == QMessageBox.Yes:
                    self.thread.quit()
                    self.thread.exit()
                    self.iterate()
                    processing_status = "Processing: Idle"
                    self.statuslabel.setText(processing_status)
                else:
                    print("No!")
            elif self.thread.isRunning() is False:
                error = 'No process is currently running.'
                detailed_error = 'You have attempted to execute the threads used for processing accelerometry data. All initialised threads have been completed.'
                self.error_message_information(error, detailed_error)

        except:
            error = 'No process is currently running.'
            detailed_error = 'You have attempted to execute the threads used for processing accelerometry data. No thread has been initialised.'
            self.error_message_information(error, detailed_error)

    def error_message_information(self, error, detailed_error):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Information)
        msg.setWindowIcon(QtGui.QIcon('Logo.svg'))
        msg.setText(error)
        msg.setWindowTitle('Error: Warning Message')
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDetailedText(detailed_error)
        msg.exec()

    def error_message_warning(self, error, detailed_error):
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Warning)
        msg.setWindowIcon(QtGui.QIcon('Logo.svg'))
        msg.setText(error)
        msg.setWindowTitle('Error: Warning Message')
        msg.setStandardButtons(QMessageBox.Ok)
        msg.setDetailedText(detailed_error)
        msg.exec()

    def iterate(self):

        column = 1

        # rowCount() This property holds the number of rows in the table
        for row in range(self.tableView.rowCount()):
            # item(row, 0) Returns the item for the given row and column if one has been set; otherwise returns nullptr.
            _item = self.tableView.item(row, column)
            if _item:
                item = self.tableView.item(row, column).text()
                if item == 'Pending' or item == 'Running':
                    self.tableView.setItem(row, column, QtWidgets.QTableWidgetItem('Cancelled'))



class WorkerThread(QThread,Ui_MainWindow, Ui_settingsWindow):
    update_progress = pyqtSignal(str)
    update_row = pyqtSignal(int)
    update_error = pyqtSignal(str)
    finished_check = pyqtSignal(bool)
    update_progress_number = pyqtSignal(int)

    def run(self):

        monitor_type = Ui_MainWindow.monitor_type

        ### Extracting the epoch_minutes from the Output Resolution List###

        outputresolution_iterate = Ui_MainWindow.outputresolutionList
        epoch_minutes = []

        for x in range(outputresolution_iterate.count()):
            epoch_minutes.append(outputresolution_iterate.item(x).text())

        epoch_minutes = [string for string in epoch_minutes if string != ""]
        epoch_minutes = [int(i) for i in epoch_minutes]


        ### Finished extraction ###

        try:
            print('using submitted settings')
            passing_settings = Ui_settingsWindow._output
            (noise_cutoff_mg, processing_epoch, epoch_plot,
             list1_increment, list1_start, list1_end,
             list2_increment, list2_start, list2_end,
             list3_increment, list3_start, list3_end,
             list4_increment, list4_start, list4_end,
             list5_increment, list5_start, list5_end) = passing_settings
            list1 = list(range(list1_start, list1_end, list1_increment))
            list2 = list(range(list2_start, list2_end, list2_increment))
            list3 = list(range(list3_start, list3_end, list3_increment))
            list4 = list(range(list4_start, list4_end, list4_increment))
            list5 = list(range(list5_start, list5_end, list5_increment))
            vals = list1 + list2 + list3 + list4 + list5  # Collection of all the cutpoints above
            stats = OrderedDict()
        except:
            print('using default')
            epoch_plot = [1]
            processing_epoch = 5
            noise_cutoff_mg = 13
            list1 = list(range(0, 5, 1))  # [0,99999],[1,99999]
            list2 = list(range(5, 150, 5))  # [5,99999],[10,99999]
            list3 = list(range(150, 300, 10))  # [100,99999],[110,99999]
            list4 = list(range(300, 1000, 100))  # [300,99999],[400,99999]
            list5 = list(range(1000, 5000, 1000))  # [1000,99999],[2000,99999]
            vals = list1 + list2 + list3 + list4 + list5  # Collection of all the cutpoints above
            stats = OrderedDict()

        checked = []
        for row in range(Ui_MainWindow.listWidget.count()):
            item = Ui_MainWindow.listWidget.item(row)
            if item.checkState():
                checked.append(item)

        checkStateInput = ", ".join(i.text() for i in checked)
        checkStateOutput = checkStateInput.split(', ')


        if 'ENMO' in checkStateOutput:
            stats["ENMO"] = [("generic", ["mean", "n", "missing", "sum"]), ("cutpoints", [[l, 99999] for l in vals])]

        if 'Pitch' in checkStateOutput:
            stats["PITCH"] = [("generic", ["mean", "std", "min", "max"]),
                              ("cutpoints", [[p, p + 5] for p in range(-90, 90, 5)])]

        if 'Roll' in checkStateOutput:
            stats["ROLL"] = [("generic", ["mean", "std", "min", "max"]),
                             ("cutpoints", [[p, p + 5] for p in range(-90, 90, 5)])]

        if 'Temperature' in checkStateOutput:
            stats["Temperature"] = [("generic", ["mean"])]

        if 'Integrity' in checkStateOutput:
            stats["Integrity"] = [("generic", ["sum"])]

        if 'HPFVM' in checkStateOutput:
            stats["HPFVM"] = [("generic", ["mean", "n", "missing", "sum"]), ("cutpoints", [[l, 99999] for l in vals])]

        if 'Battery' in checkStateOutput:
            stats["Battery"] = [("generic", ["mean"])]


        anomaly_types = ["A", "B", "C", "D", "E", "F", "G"]  # A list of known anomaly types identified by pampro

        GA_battery_max = 4.3  # maximum value of GeneActiv battery, used to find percentage ccdharged
        AX_battery_max = 210  # maximum value of Axivity battery, used to find percentage charged

        plotting_dict = {"ENMO_sum": "{}_{}_ENMO_sum.png",
                         "HPFVM_sum": "{}_{}_HPFVM_sum.png",
                         "PITCH_mean": "{}_{}_PITCH_mean.png",
                         "ROLL_mean": "{}_{}_ROLL_mean.png",
                         "Temperature_mean": "{}_{}_Temperature_mean.png",
                         "Battery_mean": "{}_{}_Battery_mean.png"}

        results_folder = Ui_MainWindow.results_folder

        count = 0

        for row in range(Ui_MainWindow.indexedRow,Ui_MainWindow.pass_table_count):

            try:
                count = count + 1
                self.update_progress_number.emit(count)
                self.update_row.emit(row)
                self.update_progress.emit('Running')
                version = "WAP_one_step_process v.1.0 04/10/2019"
                process_index = 0
                id_num = str(process_index+1)
                filename = Ui_MainWindow.pass_table.item(row,0).text()
                filename_short = os.path.basename(filename).split('.')[0]

                meta = os.path.join(results_folder, "metadata_{}.csv".format(filename_short))
                # check if analysis_meta already exists...
                if os.path.isfile(meta):
                    os.remove(meta)

                battery_max = 0
                if monitor_type == "GeneActiv":
                    battery_max = GA_battery_max
                elif monitor_type == "Axivity":
                    battery_max = AX_battery_max

                epochs = [timedelta(minutes=n) for n in epoch_minutes]
                # Use 'epochs_minutes' variable to create the corresponding names to the epochs defined
                names = []
                plots_list = []
                for n in epoch_minutes:
                    name = ""
                    if n % 60 == 0:  # If the epoch is a multiple of 60, it will be named in hours, e.g. '1h'
                        name = "{}h".format(int(n / 60))
                    elif n % 60 != 0:  # If the epoch is NOT a multiple of 60, it will be named in seconds, e.g. '15m'
                        name = "{}m".format(n)
                    names.append(name)
                    if n in epoch_plot:
                        plots_list.append(name)

                # fast-load the data to identify any anomalies:
                qc_ts, qc_header = data_loading.fast_load(filename, monitor_type)

                qc_channels = qc_ts.get_channels(["X", "Y", "Z"])

                anomalies = diagnostics.diagnose_fix_anomalies(qc_channels, discrepancy_threshold=2)

                # Load the data
                ts, header = data_loading.load(filename, monitor_type, compress=False)
                header["processed_file"] = os.path.basename(filename)

                # some monitors have manufacturers parameters applied to them, let's preserve these but rename them:
                var_list = ["x_gain", "x_offset", "y_gain", "y_offset", "z_gain", "z_offset", "calibration_date"]
                for var in var_list:
                    if var in header.keys():
                        header[("manufacturers_%s" % var)] = header[var]
                        header.pop(var)

                x, y, z, battery, temperature, integrity = ts.get_channels(
                    ["X", "Y", "Z", "Battery", "Temperature", "Integrity"])
                initial_channels = [x, y, z, battery, temperature, integrity]

                # create dictionary of anomalies total and types
                anomalies_dict = {"QC_anomalies_total": len(anomalies)}

                # check whether any anomalies have been found:
                if len(anomalies) > 0:
                    anomalies_file = os.path.join(results_folder, "{}_anomalies.csv".format(filename_short))
                    df = pd.DataFrame(anomalies)

                    for type in anomaly_types:
                        anomalies_dict["QC_anomaly_{}".format(type)] = (df.anomaly_type.values == type).sum()

                    df = df.set_index("anomaly_type")
                    # print record of anomalies to anomalies_file
                    df.to_csv(anomalies_file)

                    # if anomalies have been found, fix these anomalies
                    channels = diagnostics.fix_anomalies(anomalies, initial_channels)

                else:
                    for type in anomaly_types:
                        anomalies_dict["QC_anomaly_{}".format(type)] = 0
                    # if no anomalies
                    channels = initial_channels

                first_channel = channels[0]
                # Convert timestamps to offsets from the first timestamp
                start, offsets = Channel.timestamps_to_offsets(first_channel.timestamps)

                # As timestamps are sparse, expand them to 1 per observation
                offsets = Channel.interpolate_offsets(offsets, len(first_channel.data))

                # For each channel, convert to offset timestamps
                for c in channels:
                    c.start = start
                    c.set_contents(c.data, offsets, timestamp_policy="offset")

                # find approximate first and last battery percentage values
                first_battery_pct = round((battery.data[1] / battery_max) * 100, 2)
                last_battery_pct = round((battery.data[-1] / battery_max) * 100, 2)

                # Calculate the time frame to use
                start = time_utilities.start_of_day(x.timeframe[0])
                end = time_utilities.end_of_day(x.timeframe[-1])
                tp = (start, end)

                # if the sampling frequency is greater than 40Hz
                if x.frequency > 40:
                    # apply a low pass filter
                    x = pampro_fourier.low_pass_filter(x, 20, frequency=x.frequency, order=4)
                    x.name = "X"  # because LPF^ changes the name, we want to override that
                    y = pampro_fourier.low_pass_filter(y, 20, frequency=y.frequency, order=4)
                    y.name = "Y"
                    z = pampro_fourier.low_pass_filter(z, 20, frequency=z.frequency, order=4)
                    z.name = "Z"

                # find any bouts where data is "missing" BEFORE calibration
                missing_bouts = []
                if -111 in x.data:
                    # extract the bouts of the data channels where the data == -111 (the missing value)
                    missing = x.bouts(-111, -111)

                    # add a buffer of 2 minutes (120 seconds) to the beginning and end of each bout
                    for item in missing:
                        bout_start = max(item.start_timestamp - timedelta(seconds=120), x.timeframe[0])
                        bout_end = min(item.end_timestamp + timedelta(seconds=120), x.timeframe[1])

                        new_bout = Bout.Bout(start_timestamp=bout_start, end_timestamp=bout_end)
                        missing_bouts.append(new_bout)

                else:
                    pass

                x.delete_windows(missing_bouts)
                y.delete_windows(missing_bouts)
                z.delete_windows(missing_bouts)
                integrity.fill_windows(missing_bouts, fill_value=1)

                ################ CALIBRATION #######################

                # extract still bouts
                calibration_ts, calibration_header = triaxial_calibration.calibrate_stepone(x, y, z,
                                                                                            noise_cutoff_mg=noise_cutoff_mg)
                # Calibrate the acceleration to local gravity
                cal_diagnostics = triaxial_calibration.calibrate_steptwo(calibration_ts, calibration_header,
                                                                         calibration_statistics=False)

                # calibrate data
                triaxial_calibration.do_calibration(x, y, z, temperature=None, cp=cal_diagnostics)

                x.delete_windows(missing_bouts)
                y.delete_windows(missing_bouts)
                z.delete_windows(missing_bouts)
                temperature.delete_windows(missing_bouts)
                battery.delete_windows(missing_bouts)

                # Derive some signal features
                vm = channel_inference.infer_vector_magnitude(x, y, z)
                vm.delete_windows(missing_bouts)

                if "HPFVM" in stats:
                    vm_hpf = channel_inference.infer_vm_hpf(vm)
                else:
                    vm_hpf = None

                if "ENMO" in stats:
                    enmo = channel_inference.infer_enmo(vm)
                else:
                    enmo = None

                if "PITCH" and "ROLL" in stats:
                    pitch, roll = channel_inference.infer_pitch_roll(x, y, z)
                else:
                    pitch = roll = None

                # Infer nonwear and mask those data points in the signal
                nonwear_bouts = channel_inference.infer_nonwear_triaxial(x, y, z, noise_cutoff_mg=noise_cutoff_mg)
                for bout in nonwear_bouts:
                    # Show non-wear bouts in purple
                    bout.draw_properties = {'lw': 0, 'alpha': 0.75, 'facecolor': '#764af9'}

                for channel, channel_name in zip([enmo, vm_hpf, pitch, roll, temperature, battery],
                                                 ["ENMO", "HPFVM", "PITCH", "ROLL", "Temperature", "Battery"]):
                    if channel_name in stats:
                        # Collapse the sample data to a processing epoch (in seconds) so data is summarised
                        epoch_level_channel = \
                        channel.piecewise_statistics(timedelta(seconds=processing_epoch), time_period=tp)[
                            0]
                        epoch_level_channel.name = channel_name
                        if channel_name in ["Temperature", "Battery"]:
                            pass
                        else:
                            epoch_level_channel.delete_windows(nonwear_bouts)
                        epoch_level_channel.delete_windows(missing_bouts)
                        ts.add_channel(epoch_level_channel)

                    # collapse binary integrity channel
                    epoch_level_channel = \
                        integrity.piecewise_statistics(timedelta(seconds=int(processing_epoch)),
                                                       statistics=[("binary", ["flag"])],
                                                       time_period=tp)[0]
                    epoch_level_channel.name = "Integrity"
                    epoch_level_channel.fill_windows(missing_bouts, fill_value=1)
                    ts.add_channel(epoch_level_channel)

                    # create and open results files
                results_files = [os.path.join(results_folder, "{}_{}.csv".format(name, filename_short)) for name in names]
                files = [open(file, "w") for file in results_files]

                # Write the column headers to the created files
                for f in files:
                    f.write(pampro_utilities.design_file_header(stats) + "\n")

                # writing out and plotting results
                for epoch, name, f in zip(epochs, names, files):
                    results_ts = ts.piecewise_statistics(epoch, statistics=stats, time_period=tp, name=id_num)
                    results_ts.write_channels_to_file(file_target=f)
                    f.flush()
                    if name in plots_list:
                        # for each statistic in the plotting dictionary, produce a plot in the results folder
                        for stat, plot in plotting_dict.items():
                            try:
                                results_ts[stat].add_annotations(nonwear_bouts)
                                results_ts.draw([[stat]],
                                                file_target=os.path.join(results_folder, plot.format(filename_short, name)))
                            except KeyError:
                                pass

                header["processing_script"] = version
                header["analysis_resolutions"] = names
                header["noise_cutoff_mg"] = noise_cutoff_mg
                header["processing_epoch"] = processing_epoch
                header["QC_first_battery_pct"] = first_battery_pct
                header["QC_last_battery_pct"] = last_battery_pct

                metadata = {**header, **anomalies_dict, **cal_diagnostics}

                # write metadata to file
                pampro_utilities.dict_write(meta, id_num, metadata)

                for c in ts:
                    del c.data
                    del c.timestamps
                    del c.indices
                    del c.cached_indices

                self.update_progress.emit('Complete')

            except:
                self.update_row.emit(row)
                self.update_progress.emit('Error')

        self.finished_check.emit(True)

